# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory Monika Mittal.

Original file is located at
    https://colab.research.google.com/drive/1WifXDu3RDXbuG7QXLMRwf2RzFLdOJrWb
"""


import os

# copy content to install_required_packages.py
# Run this script to install required packages
!pip install requests PyPDF2 pytesseract pdf2image
!sudo apt install tesseract-ocr
!apt-get install poppler-utils
!pip install ultralytics

# main.py
import os
import requests
from pdf2image import convert_from_path
from PIL import Image, ImageDraw
import random
import shutil

# Function to create directories
def create_directories(base_path, sub_paths):
    for path in sub_paths:
        full_path = os.path.join(base_path, path)
        os.makedirs(full_path, exist_ok=True)
        print(f"Directory created: {full_path}")

# Function to download PDFs
def download_pdfs(base_url, form_names, download_path):
    for form in form_names:
        pdf_url = f"{base_url}/{form}.pdf"
        file_path = os.path.join(download_path, f"{form}.pdf")
        if not os.path.exists(file_path):
            response = requests.get(pdf_url)
            if response.status_code == 200:
                with open(file_path, 'wb') as file:
                    file.write(response.content)
                print(f"Downloaded: {form}.pdf")
            else:
                print(f"Failed to download {form}.pdf")

# Function to convert PDF to images
def convert_pdf_to_images(pdf_path, output_dir, form_n):
    images = convert_from_path(pdf_path)
    for i, image in enumerate(images):
        image_path = os.path.join(output_dir, f"{form_n}_page_{i + 1}.png")
        image.save(image_path, "PNG")
        print(f"Saved image: {image_path}")

def crop_annotation(image_path, annotation):
    # Load the image
    image = Image.open(image_path)
    img_width, img_height = image.size

    # Parse the annotation
    _, x_center, y_center, width, height = map(float, annotation.split())

    # Convert YOLO format to pixel values
    box_width = width * img_width
    box_height = height * img_height
    x_center *= img_width
    y_center *= img_height

    # Calculate top-left corner of the bounding box
    x1 = int(x_center - box_width / 2)
    y1 = int(y_center - box_height / 2)

    # Crop the image
    cropped_image = image.crop((x1, y1, x1 + int(box_width), y1 + int(box_height)))

    return cropped_image

def paste_on_background(background_path, cropped_image, output_image_path,output_box_path, position):
    background = Image.open(background_path)
    background_width, background_height = background.size

    # Create a copy of the background for drawing the bounding box
    background_with_box = background.copy()


    # Paste the cropped image onto the background at the specified position
    background.paste(cropped_image, position, cropped_image if cropped_image.mode == 'RGBA' else None)
    background_with_box.paste(cropped_image, position, cropped_image if cropped_image.mode == 'RGBA' else None)


    # Draw bounding box for visualization (optional)
    draw = ImageDraw.Draw(background_with_box)
    x1, y1 = position
    x2, y2 = x1 + cropped_image.width, y1 + cropped_image.height
    draw.rectangle([x1, y1, x2, y2], outline="red")

    # Save the result
    background.save(output_image_path)
    background_with_box.save(output_box_path.replace('.png', '_bbox.png'))
    print(f"Saved images to {output_image_path} and {output_box_path.replace('.png', '_bbox.png')}")


    # Calculate YOLO format coordinates
    bbox_x_center = (x1 + x2) / 2 / background_width
    bbox_y_center = (y1 + y2) / 2 / background_height
    bbox_width = cropped_image.width / background_width
    bbox_height = cropped_image.height / background_height

    yolo_format = (bbox_x_center, bbox_y_center, bbox_width, bbox_height)
    return yolo_format

def process_images(output_dir, ipath, bpath, lpath, labels_per_document):

    # COMMENT :  need to automate this automatically takes the labesl from the file
    # # give the co-ordinates of the sign box here with name of the

    for doc_type, doc_info in labels_per_document.items():
        page_number = doc_info['page_number']
        labels = doc_info['labels']
        #exclusions = doc_info.get('exclusions', [])

        doc_name = f"{doc_type}_page_{page_number}.png"
        file_path = os.path.join(output_dir, doc_name)
        for idx, label in enumerate(labels):
            cropped_image = crop_annotation(file_path, label)
            cropped_image_path = os.path.join(bpath, f'cropped_image_{doc_name.replace(".png", "")}_{idx + 1}.png')
            cropped_image.save(cropped_image_path)

            # Filter out exclusion pages
            document_paths = [os.path.join(output_dir, f) for f in os.listdir(output_dir) if f.endswith('_page_3.png') and f not in doc_name]
            for doc_path in document_paths:
                for i in range(10):
                    pos_y = random.randint(40, 2000)
                    position = (100, pos_y)
                    base_name = os.path.basename(doc_path).replace('.png', '')
                    output_image_path = os.path.join(ipath, f"{base_name}_{doc_name.replace('.png', '')}_{idx + 1}_{i}.png")
                    output_box_path = os.path.join(bpath, f"{base_name}_{doc_name.replace('.png', '')}_{idx + 1}_{i}_bbox.png")

                    yolo_coordinates = paste_on_background(doc_path, cropped_image, output_image_path, output_box_path, position)

                    with open(os.path.join(lpath, f"{base_name}_{doc_name.replace('.png', '')}_{idx + 1}_{i}.txt"), 'w') as file:
                        file.write(f"0 {yolo_coordinates[0]} {yolo_coordinates[1]} {yolo_coordinates[2]} {yolo_coordinates[3]}")

"""Copy all other images (not the 1st as they have their own sign document) with a empty label file for training dataset."""

def copy_images_and_create_labels(output_dir, ipath, lpath):
    document_paths = [os.path.join(output_dir, f) for f in os.listdir(output_dir)]

    for doc_path in document_paths:
        # Extract the base file name without page number and extension
        base_file_name = os.path.basename(doc_path).rsplit('_', 2)[0]

        page_num = 2  # Starting from the second page
        while True:
            # Construct the new page path
            page_path = os.path.join(os.path.dirname(doc_path), f"{base_file_name}_page_{page_num}.png")
            if not os.path.exists(page_path):
                break  # Stop if the page does not exist

            # Copy image to training images directory
            dest_image_path = os.path.join(ipath, f"{base_file_name}_page_{page_num}.png")
            shutil.copyfile(page_path, dest_image_path)

            # Create an empty file in labels directory
            with open(os.path.join(lpath, f"{base_file_name}_page_{page_num}.txt"), 'w') as file:
                pass  # Empty file

            page_num += 1

    print("Images and labels have been successfully copied and created.")

def prepare_validation_set(ipath, ivpath, lpath, lvpath, validation_ratio=0.2):
    # Get a list of filenames in the training images directory
    train_filenames = [os.path.splitext(f)[0] for f in os.listdir(ipath) if f.endswith('.png')]

    # Calculate the number of images to move to validation
    num_valid = int(len(train_filenames) * validation_ratio)

    # Randomly select images for validation
    valid_filenames = random.sample(train_filenames, num_valid)

    # Copy selected images and their corresponding label files to validation directories
    for filename in valid_filenames:
        # Copy image
        src_image_path = os.path.join(ipath, filename + '.png')
        dst_image_path = os.path.join(ivpath, filename + '.png')
        shutil.move(src_image_path, dst_image_path)

        # Copy label file
        src_label_path = os.path.join(lpath, filename + '.txt')
        dst_label_path = os.path.join(lvpath, filename + '.txt')
        shutil.move(src_label_path, dst_label_path)

    print(f"Copied {num_valid} images and their labels to the validation directories.")

def copy_files_to_test(output_dir, itestpath, labels_per_document):
    for doc_type, doc_info in labels_per_document.items():
        page_number = doc_info['page_number']
        file_pattern = f"{doc_type}_page_{page_number}.png"

        for filename in os.listdir(output_dir):
            if filename.endswith(file_pattern):
                source_file_path = os.path.join(output_dir, filename)
                destination_file_path = os.path.join(itestpath, filename)
                shutil.copyfile(source_file_path, destination_file_path)
                print(f"Copied {filename} to {itestpath}")

import subprocess

def train_yolo(model_path, data_yaml, epochs, img_size,dir_name_save,exp_name):
    command = f"yolo task=detect mode=train model={model_path} data={data_yaml} epochs={epochs} imgsz={img_size} project={dir_name_save} name={exp_name}"
    # to supress all the outputs on scree
    #subprocess.run(command, shell=True)
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    # Print output in real-time
    for line in iter(process.stdout.readline, b''):
        print(line.decode().rstrip())

    process.wait()

def validate_yolo(model_path, data_yaml):
    command = f"yolo task=detect mode=val model={model_path} data={data_yaml}"
    #subprocess.run(command, shell=True)
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    # Print output in real-time
    for line in iter(process.stdout.readline, b''):
        print(line.decode().rstrip())

    process.wait()

def predict_yolo(model_path, source, output_dir, confidence):
    command = f"yolo task=detect mode=predict model={model_path} conf={confidence} source={source} name={output_dir} save_txt=True"
    #subprocess.run(command, shell=True)
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    # Print output in real-time
    for line in iter(process.stdout.readline, b''):
        print(line.decode().rstrip())

    process.wait()

!cp /content/drive/MyDrive/yoloSign1/data.yaml /content/drive/MyDrive/yoloSign4/

### Don't run will take time to prepare documents for training.
### For all documents
labels_per_document = {
    'f114a' : {
        'page_number': 1,
        'labels': ["0 0.506875 0.77578125 0.9265625 0.0898125"]

    },
    'fw4': {
        'page_number': 1,
        'labels': ["0 0.506875 0.77578125 0.9265625 0.0898125"]
          # Add any exclusion pages as needed
    },
    'f1120': {
        'page_number': 1,
        'labels': ["0 0.500625 0.846875 0.9578125 0.0671875", "0 0.49375 0.9109375 0.95859375 0.06015625"]

    },
    'f1120pc': {
        'page_number': 1,
        'labels': ["0 0.50375 0.740625 0.93578125 0.06328125", "0 0.4953125 0.8046875 0.9234375 0.06328125"],

    },
    'f1120ric': {
        'page_number': 1,
        'labels': ["0 0.500625 0.71015625 0.93671875 0.0640625", "0 0.49375 0.77265625 0.93671875 0.065625"],
    },
    'f1120rei': {
        'page_number': 1,
        'labels': ["0 0.49609375 0.69453125 0.9 0.0609375","0 0.49609375 0.75546875 0.9 0.0640625"],
    },
    'f8453': {
        'page_number': 1,
        'labels': [],
    },
    'f8453crp': {
        'page_number': 1,
        'labels': ["0 0.503125 0.4875 0.928125 0.1265625","0 0.49921875 0.62734375 0.91640625 0.1546875","0 0.49921875 0.76640625 0.91640625 0.13046875"],
    },
    'f8453fe': {
        'page_number': 1,
        'labels': ["0 0.503125 0.4609375 0.9 0.20078125","0 0.50390625 0.65078125 0.9046875 0.18671875","0 0.50625 0.7953125 0.89765625 0.10859375"],
    },
    'f8453pe': {
        'page_number': 1,
        'labels': ["0 0.49375 0.4140625 0.89609375 0.1984375","0 0.496875 0.5953125 0.9 0.16875","0 0.5 0.7390625 0.90390625 0.12421875"],
    },

    'f3115': {
        'page_number': 1,
        'labels': ["0 0.50078125 0.8625 0.9359375 0.06171875", "0 0.50234375 0.91640625 0.93359375 0.0515625"],
    }


}

#Main function
def main():
    # Define base and download paths
    base_path = os.path.join(os.getcwd(), "yoloSign4")
    download_path = os.path.join(base_path, "Pdf_document")
    output_dir = os.path.join(download_path, "Pdf_To_Images")

    # Create directories
    sub_paths = ["Pdf_document", "Pdf_document/Pdf_To_Images", "train/images", "train/labels", "train/box_images", "test/images", "valid/images", "valid/labels","detect"]
    create_directories(base_path, sub_paths)


    tpath = base_path + "/train"
    ipath =  tpath + "/images/"
    lpath  = tpath + "/labels/"
    bpath  =  tpath + "/box_images/"
    testpath = base_path + "/test"
    itestpath = testpath + "/images/"
    vpath = base_path + "/valid"
    ivpath = vpath + "/images/"
    lvpath = vpath + "/labels/"
    inf_dir =  base_path + "/detect"

    # Define form names and URL
    form_names = ['f114a',
    'fw4', 'f3115', 'f1120ric', 'f1120rei',  'f1120pc', 'f1120',
    'f8453', 'f8453crp', 'f8453pe', 'f8453fe',

    #'form8453FEArkansas', 'form8453WestVirginia', 'form8453Virginia',
    #'form8453FPennsylvania', 'form8453Pennsylvania', 'form8453NewMexico',
    #'form8453FMississippi', 'form8453FEMichigan', 'form8453IITMississippi',
    #'form8453Michigan',
    'f8879pe',
    #'f8879SO', 'formEFOklahoma',
    #'form8879FKentucky'
]

    base_url = "https://www.irs.gov/pub/irs-pdf"

    # Download PDFs
    download_pdfs(base_url, form_names, download_path)

    # Convert downloaded PDFs to images
    for form in form_names:
          pdf_path = os.path.join(download_path, f"{form}.pdf")
          convert_pdf_to_images(pdf_path, output_dir, form)

    # Process images
    process_images(output_dir, ipath, bpath, lpath, labels_per_document)

    # Copy images and create label files
    copy_images_and_create_labels(output_dir, ipath, lpath)


    # Prepare validation set
    prepare_validation_set(ipath, ivpath, lpath, lvpath)



    #Prepare test data
    copy_files_to_test(output_dir, itestpath,labels_per_document )



    ## Paths for YOLO model and data
    model_dir_train = "/content/drive/MyDrive/yolov8/runs/detect/yolo8_best.pt"
    data_yaml = base_path+"/data.yaml"

    # Train YOLO model
    train_yolo(model_dir_train, data_yaml, epochs=20, img_size=640, dir_name_save=base_path, exp_name="detect")


    data_yaml = base_path+"/data.yaml"
    # Validate model
    #need to check where the modl store the weights
    model_dir = base_path + "/detect2/weights/best.pt"
    validate_yolo(model_dir, data_yaml)

    # Predict with model

    predict_yolo(model_dir, itestpath, inf_dir, confidence=0.35)


if __name__ == "__main__":
    main()





